# Classement Efficacité

RUIZ Nicolas 


## Classement : 

[options="header,footer"]
|=======================

| Place | Nom | Note
| 1 |  | 19/20 
| 2 |  | 17/20 
| 3 |  | 17/20 
| 4 |  | 16.5/20 
| 5 |  | 15/20 

|=======================

## Détails de classement : 

* 1) *a* (19/20) : noté sur 20 selon le barème, le code est complet et rempli les test donnée initialement et ceux supplémentaire. +


* 2) *61efficacite.java* (20/20) : noté sur 20 selon le barème, le code est complet et rempli les test donnée plus ceux supplémentaires. +
Le premier algorithme RLE est de compléxité O(n) et le second est de compléxité O(n x iterations). +
Le premier algortihme unRLE est de compléxité O(n) et le second est de compléxité O(n x iterations). +
Le code est très lisible et très efficace avec par exemple avec l'utilisations de StringBuilder. Il arrive a la même position, ex aequo avec 06efficacite.java +


* 3) *06efficacite.java* (20/20) : noté sur 20 selon le barème, le code est complet et rempli les test donnée plus ceux supplémentaires. +
Le premier algorithme RLE est de compléxité O(n) et le second est de compléxité O(n x iterations). +
Le premier algortihme unRLE est de compléxité O(n) et le second est de compléxité O(n x iterations). +
Le code est très lisible et très efficace avec par exemple l'utilisations de StringBuilder. +


* 4) *a* (16.5/20) : noté sur 17 selon le barème, le code est complet et rempli les test donnée initialement et ceux supplémentaire, cependant la fonction main est présente dans le fichier alors qu'elle ne doit pas y être. +


* 5) *19efficacite.py* (12.5/20) : noté sur 12.5 selon le barème, le code est incomplet, il manque 3 algorithme. Cependant l'algorithme présent rempli les test donnée initialement et ceux supplémentaire. +
Le code présent est très lisible et très efficace. Il est de compléxité O(n). +

